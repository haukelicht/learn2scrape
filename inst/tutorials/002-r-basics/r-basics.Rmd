---
title: "R basics: Data types and programming skills"
# author: "Theresa Gessler and Hauke Licht"
# date: "last updated: `r format(Sys.Date(), '%e %B %Y')`"
description: >
  Refresh your basic R programming skills.
  This tutorial reviews
  common R data types,
  how to create, access and modify objects,
  how to loop/iterate,
  and 
  how to write functions.
# output: html_document
output: learnr::tutorial
runtime: shiny_prerendered
---


```{r knitr, include=FALSE}
knitr::opts_chunk$set(
  # code chunk options
  echo = TRUE
  , eval = TRUE
  , warning = FALSE
  , message = FALSE
  , cached = FALSE 
  , exercise = TRUE
)
```

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
library(rvest)
```

## Introduction

*Last revised: `r Sys.Date()`*

This tutorial provides a description of some of the building blocks we will need to scrape and clean data from the web in this course. 

If you're having trouble following the exercises the class, I recommend you go through the following code and make sure you understand each of the concepts introduced here.

## Creating objects (assignment)

To create an object in R, we use the `<-` operator.
For example, we can create an object called 'x' with the value 1 as follows:

```{r assignment}
x <- 1
```

This is called **assignment**.
So the expression `x <- 1` reads "I assign the value 1 to an object called 'x'."

<!-- Note that there is a keyboard shortcut for inserting this operator: alt + "-" (dash) -->

After assigning an object, it can be used by referring to its name.
(The technical term is "evaluation".) 
```{r evaluation}
# create 'x'
x <- 1
# refer to 'x' (evaluate it)
x
```


Actually, you could also use `=` to assign values to objects.
However, it is an R code convention to reserve `=` for passing values to function arguments.
This makes reading code easier. 
For example:

```{r, exercise = FALSE}
res <- length(x = 1:3)
```

## Data types

R has many **data types** (see `?typeof`).
The most common (atomic) types are:

1. "logical",
2. "integer",
3. "double",
4. "character",
5. `NULL`

### 1. logical

The simplest data type is "logical".
There are only three valid logical values:  `TRUE`, `FALSE`, or `NA` ("missing").
You can check whether a value has type logical using `is.logical()`.

```{r type-logical}
typeof(TRUE)
typeof(FALSE)
typeof(NA)

is.logical(TRUE)
is.logical(FALSE)
is.logical(NA)
```

### 2. integer

Integer values are numbers: ..., -1, 0, 1, ...
You can check whether a value has type logical using `is.integer()`.
A missing integer can be created with `NA_integer_`.

Note that you have to explicitly force a number to type integer for R to recognize it aas such.
This can be done by adding an `L` behind the number (e.g. `1L`).
You need to force this behavior, because R interprets numbers as "double" type by default.

```{r type-integer}
is.integer(1) # FALSE !!!
is.integer(1L) # TRUE =)
is.integer(NA_integer_) 
```


### 3. double

Integer values are *real* numbers in (-&infin;, &infin;)
You can check whether a value has type logical using `is.double()`.
A missing integer can be created with `NA_real_` (not `NA_double_`!!!).

```{r type-double}
typeof(1)
is.double(1)
is.double(NA_real_)
```

### 4. character

Character values are strings, for example "hello world!"
You can create a character value by wrapping it inside single or double quotation marks.
A missing character values can be created with `NA_character_`.
You can check whether a value has type character using `is.character()`.

```{r type-character}
is.character('this is a valid character values')
is.character("this is also a valid character values")
is.character(NA_character_)
```

### 5. `NULL`

`NULL` is an object that represents "no data."
Contrast this with the `NA*` values introduced above.

```{r null-type}
# in the case of NULL, there is really nothing!
length(NULL)

# NA values, in contrast, represent some data
# (the value is unknown, but this is considered valid information)
length(NA)
length(NA_integer_)
length(NA_real_)
length(NA_character_)
```


## Creating vectors

You can **c**ombine values of these types in **vectors** using the `c()` function.

For example, you can combine the three valid logical values in a logical vector:

```{r creating-vectors}
# create a logical vector
logicals <- c(TRUE, FALSE, NA)
typeof(logicals)
is.logical(logicals)
```

Empty vectors can be created with the following functions:

```{r creating-empty-vectors}
logical()
integer()
double()
character()
```

Note that if you pass an positive numeric value to the `length` argument of these functions (the  default is `length = 0L`), 
you can create vectors of given length.
Note, however, that the initial values picked vary between types. 

```{r creating-fixed-length-vectors}
logical(3) # all values are `FALSE`
integer(3) # all values are `0L`
double(3) # all values are `0`
character(3) # all values are `""`
```


### Other functions for creating vectors

For certain types, there are shortcuts for creating vectors.
For example, `seq()` creates a sequence of numeric (double) values.
Specifically, `seq()` can be used to create sequence of numbers that in- or decreases by a specific amount specified by the `by` argument (the default is `by = 1L`).

```{r creating-increasing-sequences}
# increasing in steps of 1
seq(-10, 10) # equivalent to `-10:10` 

# increasing in steps of 5
seq(-10, 10, by = 5)

# NOTE: if you don't force the value passed to `by` to an integer, 
#  `seq()` will return a double vector
typeof(seq(-10, 10, by = 5))
typeof(seq(-10, 10, by = 5L))
```

You can also create decreasing sequences!
But remember to bring the start and end values in the correct order.

```{r creating-decreasing-sequences}
seq(-10, 10, by = -5L)
```

`seq()` can also be called with the argument `length.out`.
This allows creating a sequence of a pre-defined length.

```{r creating-fixed-length-sequences}
seq(-10, 10, length.out = 11)
```

Other useful functions are `seq_len()` and  `seq_along()`.
`seq_len()` takes a non-negative number as input and returns an integer sequence of equal length.

```{r seq_len}
seq_len(0)
seq_len(3)
```

`seq_along()` takes a vector as input and returns an integer sequence of equal length as the input vector.

```{r seq_along}
seq_along(c())
seq_along(c("a", "b", "c"))
```

### Naming vectors

One thing you haven't seen so far in this tutorial are **named vectors**.
You can create a named vector using name--value syntax, or with the `setNames()` function.
You can assigning names to an already existing vector using the `names()` function.

```{r naming-vectors}
# creating a named vector
c("apple" = 3, "banana" = 2, "lemon" = 1.5)
setName(c(3, 2, 1.5), c("apple", "banana", "lemon"))

# assigning names to an existing vector
capitals <- c("Lisbon", "Bejing", "Cape Town")
names(capitals) <- c("Portugal", "China", "South Afric")
```

You can access the names of a vector using the `names()` function.
```{r query-names}
prices <- c("apple" = 3, "banana" = 2, "lemon" = 1.5)
names(prices)
```

And because `names()` returns `NULL` if a vector is unnamed, you can it to check if a vector is named.

```{r check-if-named}
# create unnamed vector
x <- logical(3)
# is named?
is.null(names(x)) # `FALSE`

# name
names(x) <- c("a", "b", "c")
is.null(names(x)) # `TRUE`
```


## Extracting values

Once you have created a vector, you can access its values by **indexing** it.
To do so, use the `[` function and provide integer values to access positions as follows:

```{r integer-indexing}
fruits <- c("apple", "banana", "lemon")
# access first value
fruits[1]
# access first two values
fruits[1:2]
```

Note that by negating indexes, for example, by adding a negative sign ("dash") in front of an integer index value, you can **omit** ("drop") values:

```{r negative-indexing}
fruits <- c("apple", "banana", "lemon")
# omit first value
fruits[-1]
# omit first two values
fruits[-c(1:2)]
```

### Indexing with logical values

You can also access/omit the values of a vector using logical values.
(Note that `!` can be used to negate boolean values.)

```{r boolean-indexing}
idxs <- c(TRUE, FALSE, FALSE)
# access first value
fruits[idxs]
# negate to access last two values
fruits[!idxs]
```

### Indexing named vectors

Named vectors are useful because they allow indexing by names:
```{r name-indexing}
prices <- c("apple" = 3, "banana" = 2, "lemon" = 1.5)
prices["apple"]
prices[c("apple", "lemon")]

# NOTE: 
#  ... negative indexing doesn't work with names
prices[-c("apple", "lemon")] # this throws an ERROR!
#  ... but you can use logical indexing 
prices[!names(prices) %in% c("apple", "lemon")]
```





## Atomic and recursive types

### Atomic types 

The data types you've encountered so far in this tutorial (Logical, integer, double, character, and `NULL`) are **atomic types**.
They are "atomic" in the sense that they cannot "nest" objects of other type.
So if you use `c()` to create an atomic vector, all values need to have the *same* type.

If you violate this rule, R will convert all values to the atomic type according to the following hierarchy: logical => integer => double => character.
This is called **type conversion**.

```{r type-conversion}
# logical converts (upwards) to integer 
typeof(c(TRUE, 1L))
c(TRUE, 1L)

# logical and integer convert (upwards) to double 
typeof(c(TRUE, 1L, 1.1))
c(TRUE, 1L, 1.1)

# logical, integer and double convert (upwards) to character 
typeof(c(TRUE, 1L, 1.1, "one"))
c(TRUE, 1L, 1.1, "one")
```

Note that because `NULL` represents "no data," it is *ignored* when creating an atomic vector!

```{r null-in-vector, exercsise = TRUE}
c(NULL, "value")
```

Accordingly, it is also ignored when peforming tye conversion.

```{r null-in-type-conversion, exercsise = TRUE}
c(NULL, TRUE, 1L, 1.1, "one")
```


### Recursive types 

In contrast, **recursive types** can nest objects of other types.
The most important recursive type is "list".

## Lists

You can create a list with the `list()` functions

```{r first-list}
list(TRUE, 1L, 1.1, "one")
```

You'll note that no "type conversion" is performed inside lists!

```{r list-no-type-conversion}
# types are preserved
list(TRUE, 1L, 1.1, "one")
# types are  n o t  preserved
c(TRUE, 1L, 1.1, "one")
```

### Combining lists 

You can use `c()` to combine multiple list. 

```{r combining-lists}
c(list(1), list(2))
```

But note that when combining a list/lists and a vector/vectors, the vector(s) will be converted to a list(s)!
So **type conversion** applies beyond atomic vectors 

```{r comibing-lists-type-conversion}
c(list("hello"), c("goodbye"))
```

### Naming lists

Like vectors, lists can be named:

```{r naming-lists}
# create named list 
x <- list("logical" = TRUE, "integer" = 1L, "double" = 1.1, "character" = "one")
names(x)

# assign names to an existing list
x <- list(TRUE, 1L, 1.1, "one")
names(x) <- c("logical", "integer", "double", "character")
names(x)
```

### Indexign lists

The difference between atomic and recursive types is important because it matter for how you can **index** objects, that is, access their values.

As already shown, the values of atomic vectors can be accessed with a single square bracket `[`.
In contrast, we use double square brackets `[[` to access the values of a list.

```{r vector-vs-list}
vec <- c(1, 2)
vec[1]

lst <- list(1, 2)
lst[[1]]
```

This difference in syntax is necessary because, in contrast to atomic types, lists can be multiple levels deep.
This is illustrated by the example below:

```{r , exercise = FALSE}
# (a list of lists of lists)

# grandma Paula has two children: ...
paula <- list(
  # ... Frank
  "frank" = list(
    # Frank has two children ...
    "laura" = list(),
    "beth" = list()
  ),
  # ... and Tom
  "tom" = list(
    # ... Tom has no children
  )
)

```

To access elements at the first level, we need to use `[[`.
So to get the data for Paula' first child, Frank' we need to index the first element of the fist level.

```{r }
# get data for Paula's first child
first_child <- grandma[[1]]

# alternatively:
first_child <- grandma[["frank"]]
first_child <- grandma$frank
```

And to get at the values at the second level, we need to index even deeper:

```{r }
# get data for first child of Paula's first child
first_grandchild <- grandma[[1]][[1]]
```


There are a few special values: `NA`, which denotes a missing value, and `NaN`, which means Not a number. The values `Inf` and `-Inf` are considered numeric. `NULL` denotes a value that is undefined.

```{r na}
0 / 0 # NaN
1 / 0 # Inf
x <- c(1, NA, 0)
```

Probably one of the most useful functions in R is `str`. It displays the internal structure of an object.

```{r str}
x <- c(1, NA, 0)
str(x)
```

Of course you can always print the object in the console:

```{r print}
x <- c(1, NA, 0)
print(x)
```

Note that `print` here is a function: it takes a series of arguments (in this case, the object `x`) and returns a (set of) value(s) (`1 NA 0`).

This is equivalent to just typing the name of the object in the console. (What's going on behind the scenes is that R is calling the default function to print this object; which in this case is just `print`).

```{r print2}
x <- c(1, NA, 0)
x
```

## Data structures

Building off of the data types we've learned, *data structures* combine multiple values into a single object. Some common data structures in `R` include:

1. (atomic) vectors: sequence of values of a certain type
2. data frame: a tabular data format (like a Excel spread sheet or CSV) 
3. list: collection of objects, potentially of different types

## Vectors

We've already seen vectors created by **c**ombining multiple values with the `c` command:

```{r vectors}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)
```


With vectors we can carry out some of the most fundamental tasks in data analysis, such as computing descriptive statistics.

```{r scores}
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)

mean(math_scores)
min(math_scores - verbal_scores)
summary(verbal_scores)
```

and plots.

```{r plots}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)

plot(x = math_scores, y = verbal_scores)
text(x = math_scores, y = verbal_scores, labels = student_names)
```


It's easy to pull out specific entries in a vector using `[]`. For example,

```{r scorevectors}
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)

math_scores[3]
math_scores[1:3]
math_scores[-(4:5)]
math_scores[verbal_scores >= 90]
```

Also, you can overwrite values in a vector by assigning
```{r }
math_scores <- c(80, 75, 91, 67, 56)
math_scores[3] <- 92

```


Note that the type of the value you overwrite the existing data with will be converted to the type of the target vector

## Data frames

Data frames allow us to combine many vectors of the same length into a single object.

```{r dataframes}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)

students <- data.frame(student_names, math_scores, verbal_scores)
students
summary(students)
```

Notice that `student_names` is a different class (character) than `math_scores` (numeric), yet a data frame combines their values into a single object. We can also create data frames that include new variables:

```{r df-class, exercise.lines=20}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)
students <- data.frame(student_names, math_scores, verbal_scores)


students$final_scores <- 0
students$final_scores <- (students$math_scores + students$verbal_scores)/2

age <- c(18, 19, 20, 21, 22)
students2 <- data.frame(student_names, age)
# merge different data frames
students3 <- merge(students, students2)

students3
```

## Lists

Lists are an even more flexible way of combining multiple objects into a single object. As you will see throughout the course, we will use lists to store the output of our scraping steps. Using lists, we can combine together vectors of different lengths:

```{r lists}
list1 <- list(some_numbers = 1:10, some_letters = c("a", "b", "c"))
list1
```

or even vectors and data frames, or multiple data frames:

```{r lists2, exercise.lines=20}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)
students <- data.frame(student_names, math_scores, verbal_scores)


schools <- list(school_name = "UPF", students = students, 
                    faculty = data.frame(name = c("Kelly Jones", "Matt Smith"), 
                                         age = c(41, 55)))
schools
```

You can access a list component in several different ways:

```{r components, exercise.lines=20}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)
students <- data.frame(student_names, math_scores, verbal_scores)


schools <- list(school_name = "UPF", students = students, 
                    faculty = data.frame(name = c("Kelly Jones", "Matt Smith"), 
                                         age = c(41, 55)))

# access list components
schools[[1]]
schools[['faculty']]
schools$students
schools %>% magrittr::extract2(1)
```

A very frequent case scenario is when we have a list of data frames, and we want to bind them together:

```{r combine, exercise.lines=20}
results <- list()
# let's say here you're scraping 3 websites
results[[1]] <- data.frame(domain="google", url="www.google.com",
                           stringsAsFactors=FALSE)
results[[2]] <- data.frame(domain="facebook", url="www.facebook.com",
                           stringsAsFactors=FALSE)
results[[3]] <- data.frame(domain="twitter", url="www.twitter.com",
                           stringsAsFactors=FALSE)
# and now we want to combine all 3 data frames
results <- do.call(rbind, results)
results
```


## Loops

We use loops whenever we need to run the same chunk of code across different units. For example, we may use a loop whenever we have multiple Twitter accounts and we want to run sentiment analysis for tweets posted by each of them.

`for`-loops are probably the most common type of loop and are easily implemented in R

```{r for}
for (i in 1:10){
	print(i)
}
```

Note the structure: 


`for (i in VECTOR){ do something with i }`


In each iteration, i takes a different value of the vector; `i` can be named anything!

```{r fornumber}
for (number in 1:10){
	print(number)
}
```

The nice feature of loops is that it can use values from theprevious iteration. For instance, we can get the first 40 terms in the Fibonacci sequence using a for loop.

```{r forfib}
fib <- c(0, 1, rep(NA, 38)) 
for(i in 3:40) {
  fib[i] <- fib[i-1] + fib[i-2]
}
fib
```

Note that here we created an empty vector to store the output of each iteration. A simpler example:

```{r values}
values <- rep(NA, 10)
for (i in 1:10){
	values[i] <- i
}
values
```

A structure that we will use often in this workshop is a loop that stores some data in different elements within a list. This will be very useful when the output from each iteration is a data frame. For example:

```{r for-loop}
# create empty list
grades <- list()
# loop over 5 students
for (i in 1:5){
  # create data frame with grade/info for this student
  student <- data.frame(id = i, 
                        initial = sample(LETTERS, 1), 
                        grade = runif(n=1, min=0, max=100),
                        stringsAsFactors=F)
  grades[[i]] <- student
}
# now we have a list...
class(grades)
# but we can turn it into a data frame
grades <- do.call(rbind, grades)
grades

```

## If statements

Depending on whether a condition is true or false, we might want to execute different chunks of code.

```{r if}
compare_xy <- function(x, y) {
  if (x < y) {
    print("y is greater than x")
  } else if (x > y) {
    print("x is greater than y")
  } else {
    print("x and y are equal")
  }
}
compare_xy(3, 4)
compare_xy(4, 3)
compare_xy(1, 1)
```

A slightly different type of if statement is the `ifelse` function:

```{r ifelse}
numbers <- c(-2, -1, 0, 1, 2)
# converting them to absolute numbers
abs_numbers <- ifelse(numbers>0, numbers, -numbers)
abs_numbers
```



